/// <reference types="node" />
import { TwitterRateLimit, TwitterResponse } from '../types';
import TweetStream from '../stream/TweetStream';
import type { RequestOptions } from 'https';
import OAuth1Helper from './oauth1.helper';
export declare type TRequestFullData = {
    url: string;
    options: RequestOptions;
    body?: any;
    rateLimitSaver?: (rateLimit: TwitterRateLimit) => any;
};
export declare type TRequestFullStreamData = TRequestFullData & {
    payloadIsError?: (data: any) => boolean;
};
export declare type TRequestQuery = Record<string, string | number | boolean | string[] | undefined>;
export declare type TRequestStringQuery = Record<string, string>;
export declare type TRequestBody = Record<string, any> | Buffer;
export declare type TBodyMode = 'json' | 'url' | 'form-data' | 'raw';
interface IWriteAuthHeadersArgs {
    headers: Record<string, string>;
    bodyInSignature: boolean;
    url: URL;
    method: string;
    query: TRequestQuery;
    body: TRequestBody;
}
export interface IGetHttpRequestArgs {
    url: string;
    method: string;
    query?: TRequestQuery;
    /** The URL parameters, if you specify an endpoint with `:id`, for example. */
    params?: TRequestQuery;
    body?: TRequestBody;
    headers?: Record<string, string>;
    forceBodyMode?: TBodyMode;
    enableAuth?: boolean;
    enableRateLimitSave?: boolean;
}
export interface IGetStreamRequestArgs {
    payloadIsError?: (data: any) => boolean;
}
export declare type TCustomizableRequestArgs = Pick<IGetHttpRequestArgs, 'headers' | 'params' | 'forceBodyMode' | 'enableAuth' | 'enableRateLimitSave'>;
export declare abstract class ClientRequestMaker {
    protected _bearerToken?: string;
    protected _consumerToken?: string;
    protected _consumerSecret?: string;
    protected _accessToken?: string;
    protected _accessSecret?: string;
    protected _basicToken?: string;
    protected _clientId?: string;
    protected _oauth?: OAuth1Helper;
    protected _rateLimits: {
        [endpoint: string]: TwitterRateLimit;
    };
    protected static readonly BODY_METHODS: Set<string>;
    protected saveRateLimit(originalUrl: string, rateLimit: TwitterRateLimit): void;
    /**
     * Send a new request and returns a wrapped `Promise<TwitterResponse<T>`.
     *
     * The request URL should not contains a query string, prefers using `parameters` for GET request.
     * If you need to pass a body AND query string parameter, duplicate parameters in the body.
     */
    send<T = any>(requestParams: IGetHttpRequestArgs): Promise<TwitterResponse<T>>;
    /**
     * Send a new request, then creates a stream from its as a `Promise<TwitterStream>`.
     *
     * The request URL should not contains a query string, prefers using `parameters` for GET request.
     * If you need to pass a body AND query string parameter, duplicate parameters in the body.
     */
    sendStream<T = any>(requestParams: IGetHttpRequestArgs & IGetStreamRequestArgs): Promise<TweetStream<T>>;
    protected buildOAuth(): OAuth1Helper;
    protected getOAuthAccessTokens(): {
        key: string;
        secret: string;
    } | undefined;
    protected writeAuthHeaders({ headers, bodyInSignature, url, method, query, body }: IWriteAuthHeadersArgs): Record<string, string>;
    protected getHttpRequestArgs({ url, method, query: rawQuery, body: rawBody, headers, forceBodyMode, enableAuth, params, }: IGetHttpRequestArgs): {
        rawUrl: string;
        url: string;
        method: string;
        headers: Record<string, string>;
        body: string | Buffer | undefined;
    };
}
export {};
